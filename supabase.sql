----- Table: Folder -----
create table public.folder (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    name text not null,
    parent bigint null,
    user_id uuid not null default auth.uid (),
    constraint folder_pkey primary key (id),
    constraint folder_parent_fkey foreign key (parent) references folder (id) on delete cascade,
    constraint folder_user_id_fkey foreign key (user_id) references auth.users (id) on update cascade on delete cascade
) tablespace pg_default;


----- Table: Image -----
create table public.image (
    created_at timestamp with time zone not null default now(),
    user_id uuid not null default auth.uid (),
    folder bigint not null,
    name text not null,
    s3_id text not null,
    constraint image_pkey primary key (s3_id),
    constraint image_folder_fkey foreign key (folder) references folder (id) on update cascade on delete cascade,
    constraint image_user_id_fkey foreign key (user_id) references auth.users (id) on update cascade on delete cascade
) tablespace pg_default;


----- Function: get_folder_path -----
create or replace function get_folder_path (f_id uuid) 
returns table (id uuid, name text, parent uuid) as $$
begin
return query with recursive cte as (
    select id, name, parent
    from folder
    where id = f_id
    union
    select c.id, c.name, c.parent
    from folder c
    join cte p on p.parent = c.id
)
select id, name, parent from cte;
end;
$$ language plpgsql;


----- Function: get_nested_images -----
create or replace function get_nested_images (f_id uuid) 
returns table (s3_id text) as $$
begin
return query with recursive cte as (
    select i.s3_id, f.id as folder_id
    from folder f
    left join image i on i.folder_id = f.id
    where f.id = f_id 
    union
    select i2.s3_id, f2.id
    from folder f2
    join cte c on c.folder_id = f2.parent
    left join image i2 on i2.folder_id = f2.id
)
select cte.s3_id from cte where cte.s3_id is not null;
end;
$$ language plpgsql;


----- Function: change_user_password -----
create or replace function change_user_password(current_plain_password varchar, new_plain_password varchar)
returns json
language plpgsql
security definer
as $$
DECLARE
_uid uuid; -- for checking by 'is not found'
user_id uuid; -- to store the user id from the request
BEGIN
  -- First of all check the new password rules
  -- not empty
  IF (new_plain_password = '') IS NOT FALSE THEN
    RAISE EXCEPTION 'new password is empty';
  -- minimum 6 chars
  ELSIF char_length(new_plain_password) < 6 THEN
    RAISE EXCEPTION 'it must be at least 6 characters in length';
  END IF;
  
  -- Get user by his current auth.uid and current password
  user_id := auth.uid();
  SELECT id INTO _uid
  FROM auth.users
  WHERE id = user_id
  AND encrypted_password =
  crypt(current_plain_password::text, auth.users.encrypted_password);

  -- Check the currect password
  IF NOT FOUND THEN
    RAISE EXCEPTION 'incorrect password';
  END IF;

  -- Then set the new password
  UPDATE auth.users SET 
  encrypted_password =
  crypt(new_plain_password, gen_salt('bf'))
  WHERE id = user_id;
  
  RETURN '{"data":true}';
END;
$$


----- Function/Trigger: create_root_folder -----
create or replace function create_root_folder() returns trigger as $$ 
begin
  insert into public.folder (name, user_id)
  values('Home', new.id);
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure create_root_folder();